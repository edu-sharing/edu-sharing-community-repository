#
# Cache configuration
#
# To configure a cache, specify a series of properties where the property names begin with the
# cache name as specified in the Spring cache definition. For example, if a cache has the name
# "cache.myCache" then the properties should all start with "cache.myCache".
#
# For example:
#       cache.myCache.maxItems=20000
#       cache.myCache.timeToLiveSeconds=0
#
# The cache properties are used for both clustered and non-clustered configurations. For information
# relating to Hazelcast properties, please see the Hazelcast 2.4 documentation:
#
#       http://hazelcast.org/docs/2.4/manual/html-single
#
# The following properties are supported by both clustered and non-clustered (e.g. cluster.type=local) caches:
#
# maxItems              The maximum size a cache may reach. Use zero to set to Integer.MAX_VALUE.
# eviction-policy       When set to "NONE", the cache will not have a bounded capacity (i.e. maxItems does not apply).
#                       Any other value will cause maxItems to be enabled: use LRU or LFU if using clustered caches
#                       so that the value is compatible in both modes (required during startup). Please note, that
#                       the actual value (e.g. LRU) is of no consequence for the non-clustered caches: eviction is
#                       performed as for any Google Guava CacheBuilder created Cache.
# timeToLiveSeconds     Cache items will expire once this time has passed after creation.
# maxIdleSeconds        Cache items will expire when not accessed for this period.
#
# tx.maxItems           Not strictly speaking a supported property (as the TransactionalCache is a separate entity),
#                       but where a TransactionalCache bean has been defined, the convention has been to use
#                       {cacheName}.tx.maxItems to specify its capacity.
#
# The following properties are available for fully-distributed caches and are not supported
# by the other cache types:
#
# cluster.type          This property will determine what type of cache is created when clustering is available.
#                       Acceptable values are:
#                           fully-distributed    A Hazelcast IMap backed distributed cache will be used.
#                                                The cache values may be stored on any member of the cluster, hence
#                                                the term fully-distributed.
#                           local                Always use a non-clustered cache - the cache values will not
#                                                reflect updates made to the equivalent cache on another cluster member.
#                           invalidating         A local cache is used, but when an update or a removal is issued to the
#                                                cache then an invalidation message is broadcast to all members of the
#                                                cluster and those members will remove the value from their cache.
#                                                Useful where frequent reads are causing performance problems (due to
#                                                remote reads) or where values are non-Serializable.
# backup-count          How many cluster members should hold a backup of the key/value pair?
# readBackupData        Reads occur from backups when one is available locally (fully-distributed caches only).
# eviction-percentage   Dictates what percentage of cache entries are shed when the capacity is reached.
# merge-policy          How Hazelcast recovers from split brain syndrome, e.g. com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
#                       Please see http://hazelcast.org/docs/2.4/manual/html-single/#NetworkPartitioning


cache.propertyValueCache.backup-count=${caches.backupCount}
cache.propertyValueCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.propertyValueCache.readBackupData=${caches.readBackupData}

cache.propertyClassCache.backup-count=${caches.backupCount}
cache.propertyClassCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.propertyClassCache.readBackupData=${caches.readBackupData}

cache.contentDataSharedCache.backup-count=${caches.backupCount}
cache.contentDataSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.contentDataSharedCache.readBackupData=${caches.readBackupData}

cache.contentUrlSharedCache.backup-count=${caches.backupCount}
cache.contentUrlSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.contentUrlSharedCache.readBackupData=${caches.readBackupData}

cache.contentUrlMasterKeySharedCache.backup-count=${caches.backupCount}
cache.contentUrlMasterKeySharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.contentUrlMasterKeySharedCache.readBackupData=${caches.readBackupData}

cache.contentUrlEncryptingMasterKeySharedCache.backup-count=${caches.backupCount}
cache.contentUrlEncryptingMasterKeySharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.contentUrlEncryptingMasterKeySharedCache.readBackupData=${caches.readBackupData}

cache.immutableEntitySharedCache.backup-count=${caches.backupCount}
cache.immutableEntitySharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.immutableEntitySharedCache.readBackupData=${caches.readBackupData}

cache.node.rootNodesSharedCache.backup-count=${caches.backupCount}
cache.node.rootNodesSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.node.rootNodesSharedCache.readBackupData=${caches.readBackupData}

cache.node.allRootNodesSharedCache.backup-count=${caches.backupCount}
cache.node.allRootNodesSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.node.allRootNodesSharedCache.readBackupData=${caches.readBackupData}

cache.node.nodesSharedCache.timeToLiveSeconds=0
cache.node.nodesSharedCache.backup-count=${caches.backupCount}
cache.node.nodesSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.node.nodesSharedCache.readBackupData=${caches.readBackupData}

cache.node.aspectsSharedCache.backup-count=${caches.backupCount}
cache.node.aspectsSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.node.aspectsSharedCache.readBackupData=${caches.readBackupData}

cache.node.propertiesSharedCache.backup-count=${caches.backupCount}
cache.node.propertiesSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.node.propertiesSharedCache.readBackupData=${caches.readBackupData}

cache.node.parentAssocsSharedCache.backup-count=${caches.backupCount}
cache.node.parentAssocsSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.node.parentAssocsSharedCache.readBackupData=${caches.readBackupData}

cache.node.childByNameSharedCache.backup-count=${caches.backupCount}
cache.node.childByNameSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.node.childByNameSharedCache.readBackupData=${caches.readBackupData}

cache.userToAuthoritySharedCache.backup-count=${caches.backupCount}
cache.userToAuthoritySharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.userToAuthoritySharedCache.readBackupData=${caches.readBackupData}

cache.authenticationSharedCache.backup-count=${caches.backupCount}
cache.authenticationSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.authenticationSharedCache.readBackupData=${caches.readBackupData}

cache.authoritySharedCache.backup-count=${caches.backupCount}
cache.authoritySharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.authoritySharedCache.readBackupData=${caches.readBackupData}

cache.authorityToChildAuthoritySharedCache.backup-count=${caches.backupCount}
cache.authorityToChildAuthoritySharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.authorityToChildAuthoritySharedCache.readBackupData=${caches.readBackupData}

cache.zoneToAuthoritySharedCache.backup-count=${caches.backupCount}
cache.zoneToAuthoritySharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.zoneToAuthoritySharedCache.readBackupData=${caches.readBackupData}

cache.permissionsAccessSharedCache.backup-count=${caches.backupCount}
cache.permissionsAccessSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.permissionsAccessSharedCache.readBackupData=${caches.readBackupData}

cache.readersSharedCache.backup-count=${caches.backupCount}
cache.readersSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.readersSharedCache.readBackupData=${caches.readBackupData}

cache.readersDeniedSharedCache.backup-count=${caches.backupCount}
cache.readersDeniedSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.readersDeniedSharedCache.readBackupData=${caches.readBackupData}

cache.nodeOwnerSharedCache.backup-count=${caches.backupCount}
cache.nodeOwnerSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.nodeOwnerSharedCache.readBackupData=${caches.readBackupData}

cache.personSharedCache.backup-count=${caches.backupCount}
cache.personSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.personSharedCache.readBackupData=${caches.readBackupData}

cache.ticketsCache.maxItems=0
cache.ticketsCache.backup-count=${caches.backupCount}
cache.ticketsCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.ticketsCache.readBackupData=${caches.readBackupData}

cache.webServicesQuerySessionSharedCache.backup-count=${caches.backupCount}
cache.webServicesQuerySessionSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.webServicesQuerySessionSharedCache.readBackupData=${caches.readBackupData}

cache.aclSharedCache.backup-count=${caches.backupCount}
cache.aclSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.aclSharedCache.readBackupData=${caches.readBackupData}

cache.aclEntitySharedCache.backup-count=${caches.backupCount}
cache.aclEntitySharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.aclEntitySharedCache.readBackupData=${caches.readBackupData}

cache.resourceBundleBaseNamesSharedCache.backup-count=${caches.backupCount}
cache.resourceBundleBaseNamesSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.resourceBundleBaseNamesSharedCache.readBackupData=${caches.readBackupData}

cache.loadedResourceBundlesSharedCache.backup-count=${caches.backupCount}
cache.loadedResourceBundlesSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.loadedResourceBundlesSharedCache.readBackupData=${caches.readBackupData}

cache.messagesSharedCache.backup-count=${caches.backupCount}
cache.messagesSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.messagesSharedCache.readBackupData=${caches.readBackupData}

cache.webScriptsRegistrySharedCache.backup-count=${caches.backupCount}
cache.webScriptsRegistrySharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.webScriptsRegistrySharedCache.readBackupData=${caches.readBackupData}

cache.routingContentStoreSharedCache.backup-count=${caches.backupCount}
cache.routingContentStoreSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.routingContentStoreSharedCache.readBackupData=${caches.readBackupData}

cache.executingActionsCache.backup-count=${caches.backupCount}
cache.executingActionsCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.executingActionsCache.readBackupData=${caches.readBackupData}

cache.tagscopeSummarySharedCache.backup-count=${caches.backupCount}
cache.tagscopeSummarySharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.tagscopeSummarySharedCache.readBackupData=${caches.readBackupData}

cache.imapMessageSharedCache.backup-count=${caches.backupCount}
cache.imapMessageSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.imapMessageSharedCache.readBackupData=${caches.readBackupData}

cache.tenantEntitySharedCache.backup-count=${caches.backupCount}
cache.tenantEntitySharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.tenantEntitySharedCache.readBackupData=${caches.readBackupData}

cache.immutableSingletonSharedCache.backup-count=${caches.backupCount}
cache.immutableSingletonSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.immutableSingletonSharedCache.readBackupData=${caches.readBackupData}

cache.remoteAlfrescoTicketService.ticketsCache.maxItems=0
cache.remoteAlfrescoTicketService.ticketsCache.backup-count=${caches.backupCount}
cache.remoteAlfrescoTicketService.ticketsCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.remoteAlfrescoTicketService.ticketsCache.readBackupData=${caches.readBackupData}

cache.contentDiskDriver.fileInfoCache.backup-count=${caches.backupCount}
cache.contentDiskDriver.fileInfoCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.contentDiskDriver.fileInfoCache.readBackupData=${caches.readBackupData}

cache.globalConfigSharedCache.backup-count=${caches.backupCount}
cache.globalConfigSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.globalConfigSharedCache.readBackupData=${caches.readBackupData}

cache.propertyUniqueContextSharedCache.backup-count=${caches.backupCount}
cache.propertyUniqueContextSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.propertyUniqueContextSharedCache.readBackupData=${caches.readBackupData}

cache.siteNodeRefSharedCache.backup-count=${caches.backupCount}
cache.siteNodeRefSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.siteNodeRefSharedCache.readBackupData=${caches.readBackupData}

cache.samlTrustEngineSharedCache.backup-count=${caches.backupCount}
cache.samlTrustEngineSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.samlTrustEngineSharedCache.readBackupData=${caches.readBackupData}

cache.cachingContentStoreCache.backup-count=${caches.backupCount}
cache.cachingContentStoreCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.cachingContentStoreCache.readBackupData=${caches.readBackupData}

cache.publicapi.webScriptsRegistryCache.backup-count=${caches.backupCount}
cache.publicapi.webScriptsRegistryCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.publicapi.webScriptsRegistryCache.readBackupData=${caches.readBackupData}

cache.deletePseudoFileCache.backup-count=${caches.backupCount}
cache.deletePseudoFileCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.deletePseudoFileCache.readBackupData=${caches.readBackupData}

cache.cloudHybridSyncEventCounterCache.backup-count=${caches.backupCount}
cache.cloudHybridSyncEventCounterCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.cloudHybridSyncEventCounterCache.readBackupData=${caches.readBackupData}

cache.cloudHybridSyncDenyCache.backup-count=${caches.backupCount}
cache.cloudHybridSyncDenyCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.cloudHybridSyncDenyCache.readBackupData=${caches.readBackupData}

cache.caveatConfigCache.backup-count=${caches.backupCount}
cache.caveatConfigCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.caveatConfigCache.readBackupData=${caches.readBackupData}

cache.solrFacetNodeRefSharedCache.backup-count=${caches.backupCount}
cache.solrFacetNodeRefSharedCache.merge-policy=com.hazelcast.map.merge.LatestUpdateMapMergePolicy
cache.solrFacetNodeRefSharedCache.readBackupData=${caches.readBackupData}

cache.openCMISRegistrySharedCache.backup-count=${caches.backupCount}
cache.openCMISRegistrySharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.openCMISRegistrySharedCache.readBackupData=${caches.readBackupData}

cache.shardStateSharedCache.backup-count=${caches.backupCount}
cache.shardStateSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.shardStateSharedCache.readBackupData=${caches.readBackupData}

cache.shardToGuidSharedCache.backup-count=${caches.backupCount}
cache.shardToGuidSharedCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.shardToGuidSharedCache.readBackupData=${caches.readBackupData}

cache.authorizationCache.backup-count=${caches.backupCount}
cache.authorizationCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.authorizationCache.readBackupData=${caches.readBackupData}

cache.protectedUsersCache.backup-count=${caches.backupCount}
cache.protectedUsersCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.protectedUsersCache.readBackupData=${caches.readBackupData}

cache.authorizationCache.backup-count=${caches.backupCount}
cache.authorizationCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.authorizationCache.readBackupData=${caches.readBackupData}

cache.protectedUsersCache.backup-count=${caches.backupCount}
cache.protectedUsersCache.merge-policy=com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
cache.protectedUsersCache.readBackupData=${caches.readBackupData}
